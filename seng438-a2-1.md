**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#:      |     |
| -------------- | --- |
| Student Names: |   Harris Hasnain   |
|                |   Houssem Zaggar  |
|                |   Spencer van Roessel  |
|                |   Kaylyn Tanton |

# 1 Introduction

Text…

# 2 Detailed description of unit test strategy

// including the input partitions you have designed

During this lab, unit tests were developed for two classes, org.jfree.data.Range and org.jfree.data.DataUtilities. In general, most of the tests were developed to the standard of strong robust equivalence class testing with as many multidimensional class partitions as could be conceived. Each combination of equivalent classes were tested and implemented near the partition boundaries, on the partition boundaries, and outside the partition boundaries. Slight variation occurred for different classes and methods that required less or more comprehensive testing due to complexity. 

When testing the range class, the methods selected were contains, getLength, getLowerBound, combine, and intersect. For the contains method, the partitions were made at each of the boundaries of the range to generate the first dimension of equivalence classes. A partition was also made at the test value of zero to divide into a negative and positive equivalent class. For this specific class we did weak equivalence class testing, negative values were tested for some of the return values but not every possible value in the different locations of the ranges tested through robust boundary value testing. One dimensional equivalence class tests were implemented for getLength and getLowerBound. The classes included the range’s bounds being in the negatives, positives, and split between the two. Boundary value testing was not implemented in this case because the boundary values were more vague and insubstantial. The methods combine and intersect both involved two separate ranges. This required many partitions and an abundant number of single dimensional equivalent classes. These included different combinations of the two ranges overlapping on the upper bound of the first range, lower bound of the first range, perfectly overlapping, not overlapping, etc. Due to the large number of partitions, boundary value testing was not implemented for these two methods, however each possible combination of the two ranges was tested for strong equivalence class testing. 


# 3 Test cases developed

Text…

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

For this lab teams were divided into groups of two to carry out pair testing. Each duo planned test strategies and wrote unit tests for one of the two classes, Range or DataUtilities. Within the smaller groups, each test was developed closely together in a pair programming fashion. This enabled ideas to be bounced off one another and improved the overall cohesiveness in the organization and style of every unit test in an entire class. Test names, styles, and overall strategies were written consistently for each method evaluated. After the testing of each class was completed, both programming pairs combined and reviewed test suites to produce the final product of the lab. 

# 5 Difficulties encountered, challenges overcome, and lessons learned

Text…

# 6 Comments/feedback on the lab itself

Text…
